Features, as compared with UES-Rust and UES-LISP.

Uses home-grown memory management.
    Uses heap memory for data (allocate) instead of memory within the dictionary (alloc).

Bits value is a number, not a struct.  No difference between state or mask.
Limited by cell size, use of the sign bit may be tricky.

square pnc calc a little different.

square compare: pn 1 square rule cannot be compatible with both rules in a pn 2 square. 
                pn 1 square can be compatible to one rule in a pn-2 square, if num results are 1.
                2 X 2 can be compatible but not yet pnc.
                Change 9 possible pn comparisons into 4 functions, 1-1, 2-1, 2-2, 3-to-not-3.
                                                                   3-3 is Compatible without further tests.

Action dissimilar square pairs, whence the logical structure, is the starting point.

Square and group pn value is not stored, it is gleaned from the rulestore contents.

Changed rule union logic for two-result states.
First try union by change mask ( 0->1 + 1->0 ) only, possibly creating X->X and X->x bit positions.
Next try union by change-mask and same-result, possibly creating X->1 and X->0 bit positions.

The huge emphasis on small functions in Forth is a little too much, in my opinion.

Stack contents can be recorded, "managed", in comments, line-by-line.

Start struct functions with a struct name, and make the TOS an instance of the struct, except for <struct name>-new.
 
A function with "get" in its name returns the address of a struct field, and does not need to be
stored, or deallocated.

A function with "calc" or "new" in its name, returning a struct, that should eventually be stored or deallocated.

Intermediate struct instances can be noted in the comments with a "'", like rule1',
to help remember to store or deallocate.

I once was testing a problem, and I had a very clear perception of state samples going from two (in-order) results,
then to unpredictable, then back to two. In the end, I decided it was unpredictable. So I have
an imperative to support two-result states, even though I find them aggravating to work.
I suppose you could have n-result states, but I don't want to think about it.

